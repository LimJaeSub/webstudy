.firstsection{
    width:100%;
}
.firstsection::after{
    content:'';
    display:block;
    clear:both;
}
.division{
    width:30%;
    border:3px solid black;
    float:left;
}
h1{
    text-align:center;
}
h3{
    text-align: center;
}


p{
    border:1px solid black;
}


/* line-height */
p.normal{
    font-size:15px;
    color:red;
    line-height: normal;
}

p.lineheight1{
    font-size:15px;
    color:blue;
    line-height: 20px;
}
p.lineheight2{
    font-size:30px;
    color:black;
    line-height:4;
}
/* text-align */
p.center{
    text-align: center;
}
p.left{
    text-align: left;
}
p.right{
    text-align: right;
}


/* spacing */

p.letter{
    letter-spacing: 20px;
    /* 글자 간 간격 */
}
p.word{
    word-spacing: -10px;
    /* 단어 사이의 간격 */
}



/* text-transform */

input.upper{
    text-transform: uppercase;
}
input.lower{
    text-transform: lowercase;
}




/* text-decoration */

p.underline{
    text-decoration: underline double red;
}
p.overline{
    text-decoration: overline;
}
p.linethrough1{
    text-decoration: line-through wavy blue;
}
p.linethrough2{
    text-decoration: line-through dotted blue;
}
p.linethrough3{
    text-decoration: line-through dashed blue;
}




/* selector*/


/* property */
.property input[alt]{
    color:red;
}
.property input[type=text]{
    text-decoration:line-through;
}
.property input[alt^=start]{
    color:blue;
}
.property input[alt$=end]{
    color:aqua;
}
.property input[alt*=all]{
    color:brown;
}

/* virtual */
.virtual p{
    text-align:center;
}

.virtual p:first-child{
    color:red;
}

.virtual p:last-child{
    color:blue;
}
.virtual p:nth-child(3){
    color:aqua;
}
.virtual p:first-of-type{
    text-decoration: line-through;
}
.virtual p:last-of-type{
    text-decoration:underline;
}
.virtual p:nth-of-type(4){
    color:blueviolet;
}
.virtual a:link{
    color:lightcoral;
}
.virtual button:active{
    background-color: aqua;
}
.virtual input[type="radio"]:checked{
    box-shadow: 0 0 0 3px orange;
}
.virtual p:hover{
    color:#a200ff;
}
.virtual p:active{
    color:#00ff15;
}

/* before_after */
.before_after p:first-of-type:active::before{
    content:"Im before";
    color:red;
}
.before_after p:last-of-type:active::after{
    content:"Im after";
    color:red;
}

/* combination */
.combination .p1~span{
    color:red;
}
.combination .p2+span{
    color:blue;
}

/* inheritance */
.inheritance .parent{
    color:red;
}
.inheritance .child:first-of-type{
    color:initial;
}
.inheritance .child:nth-child(2){
    color:inherit;
}
.inheritance .child:nth-child(3){
    color:unset;
}

/* layout */
.layout .image{
    width:100px;
    height:100px;
    background-color: hotpink;
    float:left;
    /* 이 영역은 왼쪽에 둥둥 떠있다는 느낌으로 생각하면 된다. */
    margin:10px;
}
.layout p{
    border:initial;
}


/* static : 기본값(normal flow)이므로 top/bottom/left/right 옵션을 사용할 수 없다. */
.layout .relative{
    position:relative;
}
.layout .relative>div{
    width:200px;
    height:200px;
    border : 5px solid orange;
    margin-left:150px;
}

/* relative : 자기 자신을 기준으로 top/right/left/bottom값에 따라 오프셋 적용 */
#box1{
    background-color:peachpuff;
    position:relative;

    top:50px;
    left:80px;
}

/* absolute : 일반적인 문서 흐름에서 제거하고 레이아웃에 공간도 배정하지 않음. */
/* 부모 중에서 position이 static이 아닌 요소를 찾아 기준점을 삼는다. */
#box2{
    width:150px;
    height:100px;
    border-color:darkblue;
    background-color:cornflowerblue;
    border-radius: 3px;

    position:absolute;

    top:10px;
}
/* fixed : 뷰포트를 기준으로 동작한다. 스크롤을 해도 그자리에 그대로 있음.*/
/* 페이지 우측하단의 플로팅버튼을 구현할때 주로 쓰임 */
#box3{
    width:150px;
    height:100px;
    border-color:rgb(98, 182, 65);
    background-color:cornflowerblue;
    border-radius: 3px;

    position:fixed;
    bottom:40px;
    right:40px;
}



/* flex */
/* 부모 container에 display:flex 해줌 */
/* 유연하게 동작하는 속성 */

/* flex 용어 */
/* flex container와 flex item의 property를 정확하게 구분 */
/* main axis : 주축 */
/* cross axis : 주축과 수직이 되는 축 */


/* container */


/* flex-direction : 주축의 방향을 설정할 수 있다 */
/* row/row-resevse/column/column-reverse */
.container1{
    display:flex;
    flex-direction:row-reverse;
}

/* flex-wrap : 요소들이 강제로 한줄에 배치되도록 할 것인지,여러 행으로 나누어서 표현할건지 설정 */
/* nowrap : defalut */
/* wrap : 분할되어 여러 행에 걸쳐서 배치 */
.container2{
    display:flex;
    flex-wrap:wrap-reverse;
    flex-direction: row;
}
.container3{
    display:flex;
    flex-wrap:wrap-reverse;
    flex-direction: row;
}




/* item */
.item{
    width:50px;
    height:50px;
    margin:5px;
    background-color: paleturquoise;
    border:3px solid blue;
    font-size:30px;
}
/* order : 해당 item의 정렬 순서를 정해줌(낮을수록 맨앞) */
.item1:nth-child(3){
    order:-1;
}

/* flex-grow : 컨테이너의 남은 공간을 item들이 가지게됨(늘어나는 영역의 비율)*/
.item2:nth-child(2){
    flex-grow:9;
}

/* flex-basis : flex-grow에서 요소의 크기가 다를 경우의 너비차이를 잡아줌 */
/* 초기의 item 영역 */
/* basis를 0으로 두고 flex-grow를 통해 비율을 설정한다. */
.item3{
    width:initial;
    flex-grow:1;
    flex-basis:0;
}